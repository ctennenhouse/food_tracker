<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nutrition Tracker</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* This provides a clean, responsive base style for the app */
        body {
            font-family: 'Inter', sans-serif;
            @apply bg-gray-100 text-gray-800;
        }
        /* Custom scrollbar for better visuals on desktop browsers */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #e2e8f0;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #10b981;
            border-radius: 10px;
        }
		@media (max-width: 768px) {
			#historical-chart, #macro-pie-chart {
				height: 300px;
				width: 100%;
			}
		}  
		.chart-container {
			width: 100%;
			height: 400px; /* Or whatever height you prefer */
		}		
		#autocomplete-suggestions {
			position: absolute;
			background: white;
			border: 1px solid #ccc;
			max-height: 150px;
			overflow-y: auto;
			width: 100%; /* match the input width */
			z-index: 1000;
			top: 100%; /* position below input */
			left: 0;
			box-shadow: 0 2px 6px rgba(0,0,0,0.15);
		#food-input {
			position: relative; /* ensures container positioning works */
			padding-right: 2.5rem; /* space for the Ã— */
		}
		
		#clear-food-input {
			pointer-events: auto; /* always clickable */
		}

		
		      
    </style>
</head>
<body class="flex flex-col min-h-screen">

    <div id="main-app-container" class="flex-1 p-4 sm:p-6 lg:p-8">
        
        <!--
        <header class="bg-white p-4 sm:p-6 rounded-3xl shadow-lg mb-6 sticky top-0 z-10 border-b-4 border-emerald-500">
        --->
            <div class="flex items-center justify-between">

			<div class="flex items-center justify-between mb-4">
				<h1 class="flex-1 text-2xl sm:text-3xl font-bold text-center text-emerald-600">
					Nutrition Tracker
				</h1>				
				<div class="absolute top-2 right-4 flex items-center gap-2">
				<!---README.md link--->
				<a href="README.md" target="_blank" class="py-1 px-3 bg-gray-800 text-white rounded-xl hover:bg-gray-900 transition-colors duration-200 flex items-center justify-center">
					<span class="text-lg font-bold">?</span>
				</a>
					<button id="open-settings-btn" class="p-2 bg-gray-800 text-white rounded-xl hover:bg-gray-900 transition-colors duration-200">
						<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-5 h-5">
							<path stroke-linecap="round" stroke-linejoin="round" d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z"/>
							<path stroke-linecap="round" stroke-linejoin="round" d="M19.4 12a7.963 7.963 0 0 0-.2-1.5l2.1-1.5-2-3.46-2.5 1.45a7.963 7.963 0 0 0-2.6-1.5L14 2h-4l-.2 3.49a7.963 7.963 0 0 0-2.6 1.5L4.7 6.04l-2 3.46 2.1 1.5c-.1.5-.2 1-.2 1.5s.1 1 .2 1.5l-2.1 1.5 2 3.46 2.5-1.45a7.963 7.963 0 0 0 2.6 1.5L10 22h4l.2-3.49a7.963 7.963 0 0 0 2.6-1.5l2.5 1.45 2-3.46-2.1-1.5c.1-.5.2-1 .2-1.5z"/>
						</svg>
					</button>
				</div>
			</div>


            </div>

            <div class="flex items-center justify-between mb-4">
                <button id="prev-day-btn" class="p-2 sm:p-3 bg-gray-200 rounded-full hover:bg-gray-300 transition-colors duration-200">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-5 h-5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5 8.25 12l7.5-7.5" />
                    </svg>
                </button>
                <h2 id="current-date" class="text-lg sm:text-xl font-bold text-gray-800"></h2>
                <button id="next-day-btn" class="p-2 sm:p-3 bg-gray-200 rounded-full hover:bg-gray-300 transition-colors duration-200">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-5 h-5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m8.25 4.5 7.5 7.5-7.5 7.5" />
                    </svg>
                </button>
            </div>
            
            <div class="grid grid-cols-2 sm:grid-cols-4 gap-2 text-center text-sm font-semibold">
                
                <div class="bg-emerald-100 p-2 rounded-xl flex flex-col justify-between">
                    <div>
                        <span class="block text-emerald-600">Calories</span>
                        <span id="total-calories" class="text-emerald-800 text-lg font-bold">0</span>
                        <span class="text-xs text-gray-500">/ <span id="target-calories">0</span></span>
                    </div>
                    <div class="mt-2">
                        <div class="w-full bg-gray-200 rounded-full h-1.5">
                            <div id="calories-bar" class="h-1.5 rounded-full transition-all duration-300 ease-out" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>

                <div class="bg-emerald-100 p-2 rounded-xl flex flex-col justify-between">
                    <div>
                        <span class="block text-emerald-600">Protein (g)</span>
                        <span id="total-protein" class="text-emerald-800 text-lg font-bold">0</span>
                        <span class="text-xs text-gray-500">/ <span id="target-protein">0</span></span>
                    </div>
                    <div class="mt-2">
                        <div class="w-full bg-gray-200 rounded-full h-1.5">
                            <div id="protein-bar" class="h-1.5 rounded-full transition-all duration-300 ease-out" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>

                <div class="bg-emerald-100 p-2 rounded-xl flex flex-col justify-between">
                    <div>
                        <span class="block text-emerald-600">Fat (g)</span>
                        <span id="total-fat" class="text-emerald-800 text-lg font-bold">0</span>
                        <span class="text-xs text-gray-500">/ <span id="target-fat">0</span></span>
                    </div>
                    <div class="mt-2">
                        <div class="w-full bg-gray-200 rounded-full h-1.5">
                            <div id="fat-bar" class="h-1.5 rounded-full transition-all duration-300 ease-out" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>

                <div class="bg-emerald-100 p-2 rounded-xl flex flex-col justify-between">
                    <div>
                        <span class="block text-emerald-600">Carbs (g)</span>
                        <span id="total-carbs" class="text-emerald-800 text-lg font-bold">0</span>
                        <span class="text-xs text-gray-500">/ <span id="target-carbs">0</span></span>
                    </div>
                    <div class="mt-2">
                        <div class="w-full bg-gray-200 rounded-full h-1.5">
                            <div id="carbs-bar" class="h-1.5 rounded-full transition-all duration-300 ease-out" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>

            </div>
        <!--    
        </header>
		-->

		<div class="bg-white p-4 sm:p-6 rounded-3xl shadow-lg mb-6">
			
<div class="flex flex-col sm:flex-row gap-4 items-start sm:items-center w-full">
    <!-- Input wrapper -->
    <div class="relative flex-1 w-full">
        <input 
            type="text" 
            id="food-input" 
            class="w-full p-3 sm:p-4 pr-10 rounded-xl border border-gray-300 focus:outline-none focus:ring-2 focus:ring-emerald-500 transition-all duration-200" 
            placeholder="45g chicken breast, 1 medium apple"
        >
        <!-- Persistent clear button inside textbox -->
        <button 
            id="clear-food-input" 
            class="absolute right-3 top-1/2 transform -translate-y-1/2 text-black font-bold text-lg cursor-pointer"
        >&times;</button>

        <!-- Autocomplete suggestions -->
        <div id="autocomplete-suggestions" 
             class="absolute bg-white border border-gray-300 rounded-xl shadow-md top-full w-full max-h-40 overflow-y-auto hidden z-50">
        </div>
    </div>

    <!-- Buttons -->
    <button id="add-item-btn" class="w-full sm:w-auto p-3 sm:p-4 bg-emerald-500 text-white rounded-xl font-semibold hover:bg-emerald-600 focus:outline-none focus:ring-2 focus:ring-emerald-500 transition-all duration-200 shadow-md">
        Add Item
    </button>

    <button id="camera-btn" class="w-full sm:w-auto p-3 sm:p-4 bg-gray-500 text-white rounded-xl font-semibold hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 transition-all duration-200 shadow-md flex items-center justify-center">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-6 h-6">
            <path stroke-linecap="round" stroke-linejoin="round" d="M6.827 6.175A2.31 2.31 0 0 1 5.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 0 0 2.25 2.25h15A2.25 2.25 0 0 0 21.75 18V9.574c0-1.067-.75-1.994-1.802-2.15a49.123 49.123 0 0 0-1.134-.175c-.38-.054-.757-.112-1.134-.175A2.31 2.31 0 0 1 15.186 6.175M12 1.5a2.25 2.25 0 1 1 0 4.5 2.25 2.25 0 0 1 0-4.5ZM12 18.75a3.75 3.75 0 1 0 0-7.5 3.75 3.75 0 0 0 0 7.5Z" />
        </svg>
    </button>
</div>
			
			
			
			
			
			
			
		
			<div id="pending-items-notification" class="mt-4 hidden p-2 bg-yellow-100 text-yellow-800 rounded-xl text-center text-sm">
				You have pending food items that need to be processed.
			</div>
		</div>


        <div id="food-list-container" class="space-y-4"> </div>
            
		<div id="analyze-button-container" class="flex justify-center mt-6 mb-6">
			<button id="analyze-data-btn" class="w-full sm:w-auto p-3 sm:p-4 bg-indigo-500 text-white rounded-xl font-semibold hover:bg-indigo-600 transition-all duration-200 shadow-md">
				Analyze My Data
			</button>
		</div>
           
            

        <div id="message-box" class="fixed bottom-4 left-4 right-4 bg-gray-800 text-white text-center p-3 rounded-xl shadow-xl transition-opacity duration-300 opacity-0 pointer-events-none">
            Calculating...
        </div>
        
    </div>

    <div id="settings-page" class="hidden flex-1 p-4 sm:p-6 lg:p-8 bg-gray-100">
        <div class="bg-white p-6 rounded-3xl shadow-lg overflow-y-auto max-h-[90vh]">
            <h2 class="text-2xl font-bold mb-4 text-emerald-600">Settings</h2>

            <div class="mb-6">
                <h3 class="font-bold text-lg mb-2">App Info</h3>
				<p id="version-display" class="text-sm text-gray-600">
					<strong class="text-gray-900">Version:</strong>
				</p>
                <p class="mt-2 text-sm text-gray-700">
                    This app helps you track your daily nutritional intake by querying a large language model. Enter a food item with a quantity (e.g., "1 large banana") and the app will add it to your log and update your daily totals. All data is saved automatically in your browser's local storage.
                </p>
                <p class="mt-4 text-sm text-gray-700">
                    This application can use the <strong class="font-bold text-emerald-700">Gemini API</strong> to get nutritional information. To use a custom API key, you can get one for free <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-emerald-600 hover:text-emerald-800 hover:underline transition-colors duration-200">here</a>. Clicking the default button will auto-fill a link to pollinations.ai which doesn't require a key, but is not as accurate.
                </p>
            </div>
            
            <div class="mb-6">
                <h3 class="font-bold text-lg mb-2">Daily Nutrition Targets</h3>
                <label for="calorie-target-input" class="block text-sm font-medium text-gray-700">Daily Calorie Target (kcal)</label>
                <div class="mt-1 flex gap-2 items-center">
                    <input type="number" id="calorie-target-input" class="w-24 p-2 rounded-xl border border-gray-300 focus:outline-none focus:ring-2 focus:ring-emerald-500 transition-all duration-200" placeholder="e.g., 2000">
                    <button id="save-target-btn" class="p-2 bg-emerald-500 text-white rounded-xl font-semibold hover:bg-emerald-600 transition-colors duration-200">
                        Save
                    </button>
                </div>
                <p class="mt-2 text-sm text-gray-600">Based on this, your macro targets will be: <strong id="macro-targets">--</strong></p>
            </div>

            <div class="mb-6">
                <h3 class="font-bold text-lg mb-2">Your Nutrition Goals</h3>
                <label for="goals-input" class="block text-sm font-medium text-gray-700">What are your goals?</label>
                <div class="mt-1 flex gap-2">
                    <input type="text" id="goals-input" class="flex-1 p-2 rounded-xl border border-gray-300 focus:outline-none focus:ring-2 focus:ring-emerald-500 transition-all duration-200" placeholder="e.g. gain muscle, eat more fiber, etc.">
                </div>
            </div>

            <div class="mb-6">
                <h3 class="font-bold text-lg mb-2">API Usage</h3>
                <p class="text-sm text-gray-600">
                    <strong class="text-gray-900">Today's API Requests:</strong> <span id="api-request-count" class="font-semibold text-emerald-700">0</span>
                </p>
            </div>
            
            <div class="mb-6">
                <h3 class="font-bold text-lg mb-2">API Settings</h3>
                <div class="flex items-center gap-2 mb-2">
                    <button id="default-api-url-btn" class="p-2 bg-gray-200 text-gray-800 rounded-xl font-semibold hover:bg-gray-300 transition-colors duration-200 text-sm">
                        Default
                    </button>
                </div>
                <label for="api-url-input" class="block text-sm font-medium text-gray-700">New API URL</label>
                <input type="text" id="api-url-input" autocomplete="off" class="w-full p-2 rounded-xl border border-gray-300 focus:outline-none focus:ring-2 focus:ring-emerald-500 transition-all duration-200" value="https://text.pollinations.ai">
                
                <p class="text-sm text-gray-600 mb-2 mt-4">
                    <strong class="text-gray-900">Current API Key:</strong> <span id="current-api-key" class="break-words">Not Set</span>
                </p>
                <label for="api-key-input" class="block text-sm font-medium text-gray-700 mt-2">New API Key</label>
                <input type="password" id="api-key-input" class="w-full p-2 rounded-xl border border-gray-300 focus:outline-none focus:ring-2 focus:ring-emerald-500 transition-all duration-200" placeholder="Enter your API Key">
                
                <div class="flex items-center mt-4">
                    <input type="checkbox" id="use-cache-checkbox" class="h-4 w-4 text-emerald-600 border-gray-300 rounded focus:ring-emerald-500">
                    <label for="use-cache-checkbox" class="ml-2 block text-sm text-gray-900">
                        Use local cache for previous foods
                    </label>
                </div>

                <button id="save-api-settings-btn" class="mt-4 w-full p-3 bg-emerald-500 text-white rounded-xl font-semibold hover:bg-emerald-600 transition-colors duration-200">
                    Save API Settings
                </button>
            </div>

            <div class="mb-6">
                <h3 class="font-bold text-lg mb-2">Morning Food Automation</h3>
                <p class="text-sm text-gray-700 mb-2">These items will be added automatically each morning when you open the app.</p>
                <div class="flex flex-col sm:flex-row gap-2 mb-2">
                    <input type="text" id="daily-food-input" class="flex-1 p-2 rounded-xl border border-gray-300 focus:outline-none focus:ring-2 focus:ring-emerald-500 transition-all duration-200" placeholder="e.g., 2 eggs, 1 slice toast">
                    <button id="save-daily-food-btn" class="p-2 bg-emerald-500 text-white rounded-xl font-semibold hover:bg-emerald-600 transition-colors duration-200">
                        Save Item
                    </button>
                </div>
                <ul id="daily-food-list" class="list-disc list-inside text-sm text-gray-700 space-y-1 pl-4">
                    </ul>
            </div>

            <div class="space-y-4">
                <h3 class="font-bold text-lg mb-2">Data Management</h3>
                <div class="flex flex-col sm:flex-row gap-2 w-full">
                    <button id="save-settings-btn" class="flex-1 p-3 bg-gray-600 text-white rounded-xl font-semibold hover:bg-gray-700 transition-colors duration-200 text-sm">
                        Export Settings
                    </button>
                    <button id="load-settings-btn" class="flex-1 p-3 bg-gray-400 text-white rounded-xl font-semibold hover:bg-gray-500 transition-colors duration-200 text-sm">
                        Load Settings
                    </button>
                </div>
                <div class="flex flex-col sm:flex-row gap-2 w-full">
                    <button id="export-btn" class="flex-1 p-3 bg-indigo-500 text-white rounded-xl font-semibold hover:bg-indigo-600 transition-colors duration-200 text-sm">
                        Export CSV
                    </button>
                    <button id="load-data-btn" class="flex-1 p-3 bg-indigo-400 text-white rounded-xl font-semibold hover:bg-indigo-500 transition-colors duration-200 text-sm">
                        Load Data
                    </button>
                </div>
                <button id="clear-data-btn" class="w-full p-3 bg-red-500 text-white rounded-xl font-semibold hover:bg-red-600 transition-colors duration-200">
                    Clear All Data
                </button>
            </div>
            
            <button id="close-settings-btn" class="mt-6 w-full p-3 bg-gray-200 text-gray-800 rounded-xl font-semibold hover:bg-gray-300 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>
    
    <div id="analysis-page" class="hidden flex-1 p-4 sm:p-6 lg:p-8 bg-gray-100">
        <div class="bg-white p-6 rounded-3xl shadow-lg w-full max-w-4xl mx-auto overflow-y-auto max-h-[90vh]">
            <h2 class="2xl font-bold mb-4 text-indigo-600">Your Data Analysis</h2>
            
            <div id="analysis-content" class="text-gray-700 space-y-4 prose max-w-none">
                <p class="text-center text-gray-500">Analyzing your data...</p>
            </div>

            <div class="mt-8">
                <h3 class="text-xl font-bold mb-4 text-indigo-600">Historical Trends</h3>
				<div class="bg-gray-50 p-4 rounded-xl shadow-inner" style="height: 400px;">
					<canvas id="historical-chart"></canvas>
					<canvas id="macro-pie-chart"></canvas>
					<!--
					<p class="mt-2 text-sm text-gray-500 text-center">
						All values are normalized as a percentage of your daily target.
					</p>
					-->
				</div>
            </div>
            
			<div class="bg-gray-50 p-4 rounded-xl shadow-inner chart-container">
				<canvas id="historical-chart"></canvas>
				<canvas id="macro-pie-chart"></canvas>
				<!--
				<p class="mt-2 text-sm text-gray-500 text-center">
					All values are normalized as a percentage of your daily target.
				</p>
				-->
			</div>            
            
            <button id="close-analysis-btn" class="mt-6 w-full p-3 bg-gray-200 text-gray-800 rounded-xl font-semibold hover:bg-gray-300 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="generic-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4 z-50">
        <div id="modal-content" class="bg-white p-6 rounded-3xl shadow-lg w-full max-w-sm">
            </div>
    </div>

    <input type="file" id="load-settings-input" class="hidden" accept=".json">
    <input type="file" id="load-data-input" class="hidden" accept=".csv">


		<div id="camera-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center p-4 z-50">
			<div class="bg-white p-6 rounded-3xl shadow-lg w-full max-w-lg flex flex-col items-center">
				<h2 class="text-xl font-bold mb-4">Capture Photo</h2>
				<video id="camera-feed" class="w-full rounded-xl mb-4" autoplay playsinline></video>
				<canvas id="photo-canvas" class="hidden"></canvas>
				<div class="flex space-x-4 mb-4">
					<button id="swap-camera-btn" class="p-3 bg-gray-200 text-gray-800 rounded-full font-semibold hover:bg-gray-300 transition-colors duration-200">
						<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-6 h-6">
							<path stroke-linecap="round" stroke-linejoin="round" d="M7.5 21 3 16.5m0 0L7.5 12M3 16.5h18M16.5 3l4.5 4.5m0 0L16.5 12M21 7.5H3" />
						</svg>
					</button>
					<button id="take-photo-btn" class="p-3 bg-emerald-500 text-white rounded-full font-semibold hover:bg-emerald-600 transition-colors duration-200 shadow-md">
						<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-6 h-6">
							<path stroke-linecap="round" stroke-linejoin="round" d="M6.827 6.175A2.31 2.31 0 0 1 5.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 0 0 2.25 2.25h15A2.25 2.25 0 0 0 21.75 18V9.574c0-1.067-.75-1.994-1.802-2.15a49.123 49.123 0 0 0-1.134-.175c-.38-.054-.757-.112-1.134-.175A2.31 2.31 0 0 1 15.186 6.175M12 1.5a2.25 2.25 0 1 1 0 4.5 2.25 2.25 0 0 1 0-4.5ZM12 18.75a3.75 3.75 0 1 0 0-7.5 3.75 3.75 0 0 0 0 7.5Z" />
						</svg>
					</button>
				</div>
				<button id="cancel-photo-btn" class="mt-2 w-full p-3 bg-red-500 text-white rounded-xl font-semibold hover:bg-red-600 transition-colors duration-200">
					Cancel
				</button>
			</div>
		</div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Global Variables and Constants ---
            const APP_VERSION = '3.8';
            //const DEFAULT_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent";
            const DEFAULT_API_URL = "https://text.pollinations.ai";
            
            /**
             * Formats a Date object to a string (YYYY-MM-DD).
             * @param {Date} date The date object to format.
             * @returns {string} The formatted date string.
             */
            const formatDate = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };
            
			/**
			 * Checks the data for a given day and marks items as "pending" if their nutritional values are NaN.
			 * This is crucial for handling data loaded from storage after a refresh.
			 */
			const updatePendingState = (dateKey) => {
				if (!allFoodEntries[dateKey]) {
					return;
				}
				allFoodEntries[dateKey].forEach(item => {
					// If any of the nutritional values are not a valid number, mark it as pending.
					if (
						isNaN(item.calories) || isNaN(item.protein) || isNaN(item.fat) || isNaN(item.carbs) ||
						item.calories === null || item.protein === null || item.fat === null || item.carbs === null
					) {
						item.isPending = true;
					}
				});
			};
            

            // Make API_URL and API_KEY mutable variables to allow for user customization
            let API_URL = DEFAULT_API_URL;
            let API_KEY = ""; // Now saved by the user

            // --- DOM Elements ---
            const mainAppContainer = document.getElementById('main-app-container');
            const settingsPage = document.getElementById('settings-page');
            const analysisPage = document.getElementById('analysis-page');
            const foodInput = document.getElementById('food-input');
            const clearBtn = document.getElementById('clear-food-input');
			const suggestionsBox = document.getElementById('autocomplete-suggestions');
            const addItemBtn = document.getElementById('add-item-btn');
            const foodListContainer = document.getElementById('food-list-container');
            const totalCaloriesEl = document.getElementById('total-calories');
            const totalProteinEl = document.getElementById('total-protein');
            const totalFatEl = document.getElementById('total-fat');
            const totalCarbsEl = document.getElementById('total-carbs');
            const messageBox = document.getElementById('message-box');
            const openSettingsBtn = document.getElementById('open-settings-btn');
            const closeSettingsBtn = document.getElementById('close-settings-btn');
            const closeAnalysisBtn = document.getElementById('close-analysis-btn');
            const exportBtn = document.getElementById('export-btn');
            const clearDataBtn = document.getElementById('clear-data-btn');
            const apiRequestCountEl = document.getElementById('api-request-count');
            const dailyFoodInput = document.getElementById('daily-food-input');
            const saveDailyFoodBtn = document.getElementById('save-daily-food-btn');
            const dailyFoodList = document.getElementById('daily-food-list');
            const genericModal = document.getElementById('generic-modal');
            const modalContent = document.getElementById('modal-content');
            const analyzeDataBtn = document.getElementById('analyze-data-btn');
            const analysisContentEl = document.getElementById('analysis-content');
            const historicalChartCanvas = document.getElementById('historical-chart');
            const versionDisplayEl = document.getElementById('version-display');
			// Add an event listener to the food input field to handle the 'Enter' key
			foodInput.addEventListener('keydown', (event) => {
				if (event.key === 'Enter') {
					event.preventDefault(); // Prevents the default form submission (page reload)
					addItemBtn.click(); // Triggers the button's click event
				}
			});            
            
            // New and restyled buttons
            const saveSettingsBtn = document.getElementById('save-settings-btn');
            const loadSettingsBtn = document.getElementById('load-settings-btn');
            const loadDataBtn = document.getElementById('load-data-btn');
            
            // Hidden file inputs
            const loadSettingsInput = document.getElementById('load-settings-input');
            const loadDataInput = document.getElementById('load-data-input');

            // API Settings DOM elements
            const apiUrlInput = document.getElementById('api-url-input');
            const apiKeyInput = document.getElementById('api-key-input');
            const currentApiKeyEl = document.getElementById('current-api-key');
            const saveApiSettingsBtn = document.getElementById('save-api-settings-btn');
            const useCacheCheckbox = document.getElementById('use-cache-checkbox'); // New checkbox
            
            const currentDateEl = document.getElementById('current-date');
            const prevDayBtn = document.getElementById('prev-day-btn');
            const nextDayBtn = document.getElementById('next-day-btn');
            
            // Daily Target DOM elements
            const calorieTargetInput = document.getElementById('calorie-target-input');
            const saveTargetBtn = document.getElementById('save-target-btn');
            const targetCaloriesEl = document.getElementById('target-calories');
            const targetProteinEl = document.getElementById('target-protein');
            const targetFatEl = document.getElementById('target-fat');
            const targetCarbsEl = document.getElementById('target-carbs');
            const macroTargetsEl = document.getElementById('macro-targets');
            
            // Progress Bar DOM elements
            const caloriesBar = document.getElementById('calories-bar');
            const proteinBar = document = document.getElementById('protein-bar');
            const fatBar = document = document.getElementById('fat-bar');
            const carbsBar = document = document.getElementById('carbs-bar');

            // New Goals input element
            const goalsInput = document.getElementById('goals-input');
            
            // New "Default URL" button
            const defaultApiUrlBtn = document.getElementById('default-api-url-btn');

            // New pending items notification
            const pendingItemsNotification = document.getElementById('pending-items-notification');
            

			// --- Camera Functionality ---
			const cameraBtn = document.getElementById('camera-btn');
			const cameraModal = document.getElementById('camera-modal');
			const video = document.getElementById('camera-feed');
			const photoCanvas = document.getElementById('photo-canvas');
			const takePhotoBtn = document.getElementById('take-photo-btn');
			const cancelPhotoBtn = document.getElementById('cancel-photo-btn');
			const swapCameraBtn = document.getElementById('swap-camera-btn');
			let currentStream;
			let facingMode = 'environment'; // 'user' for front camera, 'environment' for rear
			
			// Function to convert data URL to Base64 and MIME type
			function dataURLtoBase64AndMime(dataURL) {
				const [mimePart, base64Part] = dataURL.split(',');
				const mimeType = mimePart.match(/:(.*?);/)[1];
				return {
					base64: base64Part,
					mimeType: mimeType
				};
			}
			
			// Function to start the camera stream
			async function startCamera() {
				if (currentStream) {
					currentStream.getTracks().forEach(track => track.stop());
				}
				const constraints = {
					video: {
						facingMode: facingMode
					}
				};
				try {
					currentStream = await navigator.mediaDevices.getUserMedia(constraints);
					video.srcObject = currentStream;
					video.onloadedmetadata = () => {
						video.play();
					};
					video.onplaying = () => {
						cameraModal.style.display = 'flex';
					};
				} catch (err) {
					console.error("Error accessing camera: ", err);
					alert('Could not access the camera. Please ensure you have granted permission.');
					cameraModal.style.display = 'none';
				}
			}
			
			/*
			// Function to stop the camera stream
			// replaced with resetCameraModal
			function stopCamera() {
				if (currentStream) {
					currentStream.getTracks().forEach(track => track.stop());
				}
				cameraModal.style.display = 'none';
			}
			*/
			
			// Event listener for the camera button
			cameraBtn.addEventListener('click', startCamera);
			
			// Event listener for the cancel button
			cancelPhotoBtn.addEventListener('click', () => {
				// Reset the camera modal to close it and clean up the UI
				resetCameraModal();
			});
			
			// Event listener to swap cameras
			swapCameraBtn.addEventListener('click', () => {
				facingMode = facingMode === 'environment' ? 'user' : 'environment';
				startCamera();
			});
			
			/**
			 * Stops the camera stream and resets the modal UI state.
			 */
			function resetCameraModal() {
				if (currentStream) {
					currentStream.getTracks().forEach(track => track.stop());
					currentStream = null;
				}
				
				// Resetting the UI elements
				cameraModal.style.display = 'none';
				video.style.display = 'block'; // Ensure video is visible for the next session
				photoCanvas.style.display = 'none'; // Ensure canvas is hidden
				takePhotoBtn.disabled = false; // Re-enable the button
			}			
			
			
			/**
			 * Processes a JSON string response from the LLM API and adds the item to the food list.
			 * @param {string} jsonString The raw JSON string from the LLM.
			 * @param {string} originalFoodText The original text used for the pending item.
			 */
			const processApiResponse = async (jsonString, originalFoodText) => {
				let nutritionData = null;
				let fromCache = false;
			
				// Create a new entry, pending or not
				const newEntry = {
					id: Date.now(),
					text: originalFoodText,
					timestamp: new Date().toISOString(),
					calories: 0,
					protein: 0,
					fat: 0,
					carbs: 0,
					isPending: true // Assume pending until API response is processed
				};
			
				const dateKey = formatDate(currentDate);
				if (!allFoodEntries[dateKey]) {
					allFoodEntries[dateKey] = [];
				}
				// push new item to top of list
				allFoodEntries[dateKey].unshift(newEntry);
			
				try {
					let jsonText = jsonString;
			
					// Remove Markdown code block if present
					if (jsonText.startsWith("```json")) {
						jsonText = jsonText.replace(/^```json\s*|\s*```$/g, '');
					}
			
					nutritionData = JSON.parse(jsonText);
			
					if (nutritionData &&
						typeof nutritionData.calories === 'number' &&
						typeof nutritionData.protein === 'number' &&
						typeof nutritionData.fat === 'number' &&
						typeof nutritionData.carbs === 'number') {
			
						// Update the newly created entry with real data
						newEntry.text = nutritionData.food_name || originalFoodText;
						newEntry.calories = nutritionData.calories;
						newEntry.protein = nutritionData.protein;
						newEntry.fat = nutritionData.fat;
						newEntry.carbs = nutritionData.carbs;
						newEntry.isPending = false;
			
						showMessage(`${newEntry.text} added!`,2000);
					} else {
						throw new Error("Invalid nutrition data received from API.");
					}
				} catch (e) {
					console.error('Failed to process API response:', e);
					showMessage(`Item "${originalFoodText}" saved as pending.`, 2000);
				}
				
				// Update the UI
				renderFoodList();
				updateTotals();
				addItemBtn.disabled = false;
			};
			
			
			// Event listener for taking a photo
			takePhotoBtn.addEventListener('click', async () => {
				// Disable the button to prevent multiple clicks
				takePhotoBtn.disabled = true;
			
				// Calculate dimensions to fit the photo within a reasonable size (e.g., max 400px width for the output)
				const maxWidth = 400; // Max width for the captured image within the modal
				const aspectRatio = video.videoWidth / video.videoHeight;
				
				let newWidth = video.videoWidth;
				let newHeight = video.videoHeight;
			
				if (newWidth > maxWidth) {
					newWidth = maxWidth;
					newHeight = newWidth / aspectRatio;
				}
			
				// Set canvas dimensions to the calculated size
				photoCanvas.width = newWidth;
				photoCanvas.height = newHeight;
			
				// Draw the current video frame to the canvas, scaled
				const context = photoCanvas.getContext('2d');
				context.drawImage(video, 0, 0, newWidth, newHeight); // Draw at the new scaled dimensions
			
				// Freeze the image by hiding the video and showing the canvas
				video.style.display = 'none';
				photoCanvas.style.display = 'block';
				photoCanvas.style.maxWidth = '100%'; // Ensure it respects parent container width
				photoCanvas.style.height = 'auto'; // Maintain aspect ratio
			
			
				// Get the image data as a base64 encoded string
				const imageData = photoCanvas.toDataURL('image/jpeg');
				
				// close camera pop-up
				resetCameraModal();
			
				// Define the prompt for the image
				const image_prompt = `Provide the nutritional information for the food item in this image, including an estimate for weight or volume if applicable (e.g. "45g chicken breast" or "1 cup white rice"). If the image is a bar code then search for a food product with this bar code. If you are unsure what the item is, make your best guess. Respond only with a JSON object. The JSON should have the following structure: { "food_name": "...", "calories": 0, "protein": 0, "fat": 0, "carbs": 0 }. All values should be numerical (calories, protein, fat, carbs) and represent the total for the specified serving. Do not respond with anything other than a properly formed JSON object. If you do not know the values then provide your best guess. Any other response is unacceptable.?json=true`;
			
				// Add a pending item to the list immediately
				const pendingText = "Processing image...";
				showMessage('Processing image...');
				addItemBtn.disabled = true;
				
			
				// Call the LLM with the prompt and image data
				const result = await callLLM(image_prompt, imageData);
				
				// Clear the processing message once the API call is done
				clearMessage();
			
				// Now, process the API response and update the list
				if (result) {
					await processApiResponse(result, pendingText);
				} else {
					showMessage("No valid data returned from image scan. Please try again or enter manually.",2000);
				}
				
			});

                

            // --- State Variables ---
            // `allFoodEntries` now stores all food entries, organized by date
            let allFoodEntries = {}; 
            let apiRequests = { count: 0, date: '' };
            let dailyFoodEntries = [];
            let currentDate = new Date();
            let dailyCalorieTarget = 2000;
            let myChart = null;
            let macroPieChart = null;
            let foodCache = {}; // New: Cache for storing food data
            let useFoodCache = true; // New: Flag to control caching behavior
            let userGoals = ""; // New: User's goals
            
            // update the version number
            versionDisplayEl.textContent = `Version: v${APP_VERSION}`;
            
            // --- Helper Functions ---
            
            /**
             * Formats a Date object for display (e.g., "Today", "Yesterday", or "Monday, May 26").
             * @param {Date} date The date object to format.
             * @returns {string} The user-friendly date string.
             */
            const formatDisplayDate = (date) => {
                const today = new Date();
                const yesterday = new Date();
                yesterday.setDate(today.getDate() - 1);
                
                if (formatDate(date) === formatDate(today)) {
                    return "Today";
                } else if (formatDate(date) === formatDate(yesterday)) {
                    return "Yesterday";
                } else {
                    return date.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });
                }
            };
            
			/**
			 * Adds a food item to today's date, regardless of the currently viewed date.
			 * @param {object} item The food item object to add.
			 * @param {string} currentDateKey The formatted date key for the currently viewed date.
			 */
			const addFoodItemToToday = (item, currentDateKey) => {
				// Get today's date
				const today = new Date();
				const todayKey = formatDate(today);
			
				// Create a new entry with the item's data
				const newEntry = {
					id: Date.now(),
					text: item.text,
					timestamp: new Date().toISOString(),
					calories: item.calories,
					protein: item.protein,
					fat: item.fat,
					carbs: item.carbs,
					isPending: false
				};
				
				// Initialize the list for today if it doesn't exist
				if (!allFoodEntries[todayKey]) {
					allFoodEntries[todayKey] = [];
				}
			
				// Add the new entry to today's list
				allFoodEntries[todayKey].unshift(newEntry);
				
				// Call the correct function to save the updated data
				saveEntries();
				
				// If the user is currently viewing today's date, re-render the list
				const isViewingToday = currentDateKey === todayKey;
				if (isViewingToday) {
					renderFoodList();
					updateTotals();
				}
			
				showMessage(`${item.text} added to today's list!`,2000);
			};          
            

			/*
			* Code for dropdown menu to autocomplete entered food items
			*/            
			// load from local storage to make suggestions			
			const getFoodHistory = () => {
				const history = [];
				// newest dates first
				const dates = Object.keys(allFoodEntries).sort().reverse();
				dates.forEach(date => {
					allFoodEntries[date].forEach(item => {
						if (item.text) history.push(item.text);
					});
				});
			
				// dedupe while keeping first occurrence (most recent)
				const seen = new Set();
				const deduped = history.filter(text => {
					if (seen.has(text)) return false;
					seen.add(text);
					return true;
				});
			
				return deduped;
			};




			// scroll to top when keyboard opens
			foodInput.addEventListener("focus", () => {
				setTimeout(() => {
					foodInput.scrollIntoView({ behavior: "smooth", block: "start" });
				}, 300); // small delay for keyboard
			});
			

			
			// Show suggestions as user types
			foodInput.addEventListener('input', () => {
				const query = foodInput.value.trim().toLowerCase();
			

				if (!query) {
					suggestionsBox.classList.add('hidden');
					return;
				}
			
				const matches = getFoodHistory()
					.filter(name => name.toLowerCase().includes(query))
					.slice(0, 6); // show only recent 6 matches
			
				suggestionsBox.innerHTML = '';
				if (matches.length === 0) {
					suggestionsBox.classList.add('hidden');
					return;
				}
			
				matches.forEach(match => {
					const div = document.createElement('div');
					div.textContent = match;
					div.className = 'p-2 cursor-pointer hover:bg-emerald-100';
					div.onclick = () => {
						foodInput.value = match;
						suggestionsBox.classList.add('hidden');
					};
					suggestionsBox.appendChild(div);
				});
			
				suggestionsBox.classList.remove('hidden');
			});
            
            
            
            /**
             * A simple Markdown to HTML converter. It's not a full parser, but it handles common
             * formatting like bold, italics, headers, and lists.
             * @param {string} markdownText The text containing Markdown.
             * @returns {string} The converted HTML string.
             */
            const convertMarkdownToHtml = (markdownText) => {
                let htmlText = markdownText;
                
                // Convert bold: **text** or __text__ to <strong>text</strong>
                htmlText = htmlText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                htmlText = htmlText.replace(/__(.*?)__/g, '<strong>$1</strong>');

                // Convert italics: *text* or _text_ to <em>text</em>
                htmlText = htmlText.replace(/\*(.*?)\*/g, '<em>$1</em>');
                htmlText = htmlText.replace(/_(.*?)_/g, '<em>$1</em>');
                
                // Convert headers: # Header -> <h1>Header</h1> (and so on)
                htmlText = htmlText.replace(/^###\s(.*$)/g, '<h3>$1</h3>');
                htmlText = htmlText.replace(/^##\s(.*$)/g, '<h2>$1</h2>');
                htmlText = htmlText.replace(/^#\s(.*$)/g, '<h1>$1</h1>');
                
                // Convert bullet points: * Item -> <ul><li>Item</li>...</ul>
                // This is a simplified version for common cases
                const items = htmlText.split('\n');
                let inList = false;
                const newItems = items.map(line => {
                    if (line.trim().startsWith('* ')) {
                        if (!inList) {
                            inList = true;
                            return `<ul><li>${line.trim().substring(2)}</li>`;
                        }
                        return `<li>${line.trim().substring(2)}</li>`;
                    } else {
                        if (inList) {
                            inList = false;
                            return `</ul><p>${line}</p>`;
                        }
                        return `<p>${line}</p>`;
                    }
                });
                if (inList) {
                    newItems.push('</ul>');
                }
                htmlText = newItems.join('');

                // Replace double newlines with a paragraph tag for better spacing
                htmlText = htmlText.replace(/\n\n/g, '</p><p>');

                return htmlText;
            };
            
            /**
             * Strips all markdown symbols from a string.
             * @param {string} markdownText The text containing Markdown.
             * @returns {string} The plain text string.
             */
            const stripMarkdown = (markdownText) => {
                // Remove headers (#)
                let plainText = markdownText.replace(/^#+\s/gm, '');
                // Remove bold/italics (* and _)
                plainText = plainText.replace(/(\*|_)+/g, '');
                // Remove list markers (-)
                plainText = plainText.replace(/^\s*[\-\*]\s/gm, '');
                return plainText;
            };

			/**
			 * Shows a message box for user feedback.
			 * @param {string} message The message to display.
			 * @param {number} [duration] Optional duration in milliseconds. If omitted, message is persistent.
			 */
			const showMessage = (message, duration) => {
				messageBox.textContent = message;
				messageBox.classList.remove('opacity-0', 'pointer-events-none');
				messageBox.classList.add('opacity-100');
			
				if (duration) {
					setTimeout(() => {
						messageBox.classList.remove('opacity-100');
						messageBox.classList.add('opacity-0', 'pointer-events-none');
					}, duration);
				}
			};
			
			// Clears the message manually
			const clearMessage = () => {
				messageBox.classList.remove('opacity-100');
				messageBox.classList.add('opacity-0', 'pointer-events-none');
			};

			
			/**
			 * Shows a custom modal with dynamic content.
			 * @param {string} htmlContent The HTML string to inject into the modal.
			 * @param {function} onConfirm The callback function to run on confirmation.
			 */
			const showModal = (htmlContent, onConfirm) => {
				modalContent.innerHTML = htmlContent;
				genericModal.classList.remove('hidden');
				genericModal.classList.add('flex');
			
				const confirmBtn = modalContent.querySelector('#modal-confirm-btn');
				const cancelBtn = modalContent.querySelector('#modal-cancel-btn');
				const addToTodayBtn = modalContent.querySelector('#modal-add-to-today-btn');
				
				// Add event listeners that pass the click event
				if (confirmBtn) {
					confirmBtn.onclick = (e) => { // Pass the event object 'e'
						onConfirm(e, modalContent); // Pass 'e' to the callback
						hideModal();
					};
				}
				
				if (cancelBtn) {
					cancelBtn.onclick = hideModal;
				}
			
				if (addToTodayBtn) {
					addToTodayBtn.onclick = (e) => { // Pass the event object 'e'
						onConfirm(e, modalContent); // Pass 'e' to the callback
						hideModal();
					};
				}
			};
            
            /** Hides the custom modal. */
            const hideModal = () => {
                genericModal.classList.add('hidden');
                genericModal.classList.remove('flex');
                modalContent.innerHTML = '';
            };
            
            /**
             * Calculates the daily macronutrient targets based on the calorie target.
             * Uses a standard ratio: 50% Carbs, 30% Fat, 20% Protein.
             * 1g Protein = 4 kcal, 1g Fat = 9 kcal, 1g Carbs = 4 kcal.
             * @returns {object} An object containing the calculated targets in grams.
             */
            const calculateTargets = () => {
                const proteinTarget = (dailyCalorieTarget * 0.20) / 4;
                const fatTarget = (dailyCalorieTarget * 0.30) / 9;
                const carbsTarget = (dailyCalorieTarget * 0.50) / 4;
                return {
                    calories: dailyCalorieTarget,
                    protein: proteinTarget,
                    fat: fatTarget,
                    carbs: carbsTarget
                };
            };
            
            /**
             * Updates the progress bar based on current and target values.
             * @param {HTMLElement} barElement The progress bar div element.
             * @param {number} current The current value.
             * @param {number} target The target value.
             */
            const updateProgressBar = (barElement, current, target) => {
                let percent = 0;
                if (target > 0) {
                    percent = Math.min(100, (current / target) * 100);
                }
                barElement.style.width = `${percent}%`;
                
                // Set color based on progress
                if (current > target) {
                    barElement.style.backgroundColor = '#f97316'; // orange-500
                } else {
                    barElement.style.backgroundColor = '#10b981'; // emerald-500
                }
            };

            /** Calculates and displays daily totals and targets for the current date. */
            const updateTotals = () => {
                const dateKey = formatDate(currentDate);
                // Filter out pending items before calculating totals
                const currentDayEntries = (allFoodEntries[dateKey] || []).filter(item => !item.isPending);

                
                // Sum the nutritional values of all entries for the current day
                const totals = currentDayEntries.reduce((acc, curr) => {
                    acc.calories += curr.calories;
                    acc.protein += curr.protein;
                    acc.fat += curr.fat;
                    acc.carbs += curr.carbs;
                    return acc;
                }, { calories: 0, protein: 0, fat: 0, carbs: 0 });

                // Get the calculated daily targets
                const targets = calculateTargets();

                // Update the main page display with current totals
                totalCaloriesEl.textContent = Math.round(totals.calories);
                totalProteinEl.textContent = Math.round(totals.protein);
                totalFatEl.textContent = Math.round(totals.fat);
                totalCarbsEl.textContent = Math.round(totals.carbs);
                
                // Update the main page display with daily targets
                targetCaloriesEl.textContent = Math.round(targets.calories);
                targetProteinEl.textContent = Math.round(targets.protein);
                targetFatEl.textContent = Math.round(targets.fat);
                targetCarbsEl.textContent = Math.round(targets.carbs);
                
                // Update progress bars
                updateProgressBar(caloriesBar, totals.calories, targets.calories);
                updateProgressBar(proteinBar, totals.protein, targets.protein);
                updateProgressBar(fatBar, totals.fat, targets.fat);
                updateProgressBar(carbsBar, totals.carbs, targets.carbs);

                // Save to local storage whenever totals are updated
                saveEntries();
                updatePendingNotification();
            };

            /** Saves all food entries to localStorage. */
            const saveEntries = () => {
                try {
                    localStorage.setItem('allFoodEntries', JSON.stringify(allFoodEntries));
                } catch (e) {
                    console.error('Failed to save food entries to localStorage:', e);
                    showMessage('Could not save data.', 3000);
                }
            };
            
            /** Saves food cache to localStorage. */
            const saveFoodCache = () => {
                try {
                    localStorage.setItem('foodCache', JSON.stringify(foodCache));
                } catch (e) {
                    console.error('Failed to save food cache to localStorage:', e);
                }
            };

            /** Saves daily food entries (for automation) to localStorage. */
            const saveDailyEntries = () => {
                try {
                    localStorage.setItem('dailyFoodEntries', JSON.stringify(dailyFoodEntries));
                    renderDailyFoodList();
                } catch (e) {
                    console.error('Failed to save daily food entries:', e);
                    showMessage('Could not save daily food items.', 3000);
                }
            };

            /** Loads daily food entries from localStorage. */
            const loadDailyEntries = () => {
                try {
                    const savedDailyEntries = localStorage.getItem('dailyFoodEntries');
                    if (savedDailyEntries) {
                        dailyFoodEntries = JSON.parse(savedDailyEntries);
                    }
                } catch (e) {
                    console.error('Failed to load daily food entries:', e);
                    dailyFoodEntries = [];
                }
            };
            
            /** Updates the display for the number of pending items. */
            const updatePendingNotification = () => {
                let hasPending = false;
                for (const date in allFoodEntries) {
                    if (allFoodEntries[date].some(item => item.isPending)) {
                        hasPending = true;
                        break;
                    }
                }

                if (hasPending) {
                    pendingItemsNotification.classList.remove('hidden');
                } else {
                    pendingItemsNotification.classList.add('hidden');
                }
            };

            /** Loads the daily calorie target from local storage. */
            const loadCalorieTarget = () => {
                try {
                    const savedTarget = localStorage.getItem('dailyCalorieTarget');
                    if (savedTarget) {
                        dailyCalorieTarget = parseInt(savedTarget, 10);
                    }
                } catch (e) {
                    console.error('Failed to load daily calorie target:', e);
                }
            };

            /** Saves the current daily calorie target to local storage. */
            const saveCalorieTarget = () => {
                localStorage.setItem('dailyCalorieTarget', dailyCalorieTarget);
            };
            
            /** Loads user goals from local storage. */
            const loadGoals = () => {
                try {
                    const savedGoals = localStorage.getItem('userGoals');
                    if (savedGoals) {
                        userGoals = savedGoals;
                    }
                } catch (e) {
                    console.error('Failed to load goals:', e);
                    userGoals = "";
                }
            };

            /** Saves user goals to local storage. */
            const saveGoals = () => {
                localStorage.setItem('userGoals', userGoals);
            };

            /**
             * Renders the list of food entries for the current day.
             * It's called after adding, editing, or deleting an item, or changing the day.
             */
            const renderFoodList = () => {
                foodListContainer.innerHTML = '';
                
                const dateKey = formatDate(currentDate);
                const currentDayEntries = allFoodEntries[dateKey] || [];

                
                if (currentDayEntries.length === 0) {
                    foodListContainer.innerHTML = `
                        <p class="text-center text-gray-500 italic p-4 rounded-xl border border-dashed border-gray-300">
                            No food items for this day. Add an item above!
                        </p>
                    `;
                } else {
                    currentDayEntries.forEach((item, index) => {
                        // Apply different styling for pending items
                        const itemClass = item.isPending
                            ? 'bg-yellow-100 p-4 sm:p-5 rounded-3xl shadow-md flex justify-between items-center transition-transform duration-200 transform hover:scale-[1.01] border-2 border-yellow-400'
                            : 'bg-white p-4 sm:p-5 rounded-3xl shadow-md flex justify-between items-center transition-transform duration-200 transform hover:scale-[1.01]';
                        
                        const nutritionHtml = item.isPending
                            ? `<span class="italic text-gray-500">pending...</span>`
                            : `<span class="font-bold">${Math.round(item.calories)}</span> kcal â€¢ <span class="font-bold">${Math.round(item.protein)}</span> P â€¢ <span class="font-bold">${Math.round(item.fat)}</span> F â€¢ <span class="font-bold">${Math.round(item.carbs)}</span> C`;
                        
                        const foodItemEl = document.createElement('div');
                        foodItemEl.className = itemClass;
                        foodItemEl.innerHTML = `
                            <div class="flex-1">
                                <h3 class="text-lg font-semibold text-gray-900">${item.text}</h3>
                                <p class="text-sm text-gray-600">${nutritionHtml}</p>
                            </div>
                            <div class="flex items-center space-x-2 sm:space-x-3 ml-4">
                                <button class="edit-item-btn p-2 rounded-full bg-blue-100 text-blue-600 hover:bg-blue-200 transition-colors duration-200" data-index="${index}">
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-4 h-4">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" />
                                    </svg>
                                </button>
                                <button class="delete-item-btn p-2 rounded-full bg-red-100 text-red-600 hover:bg-red-200 transition-colors duration-200" data-index="${index}">
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-4 h-4">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.914a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m-1.022.165L5.79 19.673a2.25 2.25 0 0 0 2.244 2.077h.262m-12.244-1.284v.252" />
                                    </svg>
                                </button>
                            </div>
                        `;
                        foodListEl = foodListContainer.appendChild(foodItemEl);
                        
                        // Add a click listener to the entire item to bring up a prompt to re-process if pending
                        if (item.isPending) {
                            foodItemEl.addEventListener('click', (event) => {
                                // Don't trigger if the user clicked the edit/delete buttons
                                if (event.target.closest('button')) {
                                    return;
                                }
                                
                                const modalHtml = `
                                    <h3 class="font-bold text-lg mb-2">Re-process Item</h3>
                                    <p class="text-sm text-gray-600 mb-4">It looks like this item is pending. Would you like to try processing it again?</p>
                                    <div class="flex justify-end gap-2">
                                        <button id="modal-cancel-btn" class="px-4 py-2 text-gray-600 rounded-lg hover:bg-gray-200 transition-colors duration-200">Cancel</button>
                                        <button id="modal-confirm-btn" class="px-4 py-2 bg-emerald-500 text-white rounded-lg hover:bg-emerald-600 transition-colors duration-200">Process Now</button>
                                    </div>
                                `;
                                showModal(modalHtml, async () => {
                                    showMessage("Processing item...");
                                    try {
                                        const nutritionData = await getNutritionData(item.text);
                                        // clear processing message
                                        clearMessage();
                                        if (nutritionData) {
                                            item.text = nutritionData.food_name || item.text;
                                            item.calories = nutritionData.calories;
                                            item.protein = nutritionData.protein;
                                            item.fat = nutritionData.fat;
                                            item.carbs = nutritionData.carbs;
                                            item.isPending = false;
                                            showMessage('Item updated successfully!',2000);
                                        } else {
                                            showMessage('Could not process the item at this time.', 3000);
                                        }
                                    } catch (e) {
                                        showMessage('Could not process the item. Check your internet connection or API settings.', 3000);
                                    }
                                    renderFoodList();
                                    updateTotals();
                                });
                            });
                        }
                    });
                }
            };

            /** Renders the list of automated daily food items in the settings page. */
            const renderDailyFoodList = () => {
                dailyFoodList.innerHTML = '';
                if (dailyFoodEntries.length === 0) {
                    dailyFoodList.innerHTML = `<li class="text-gray-500 italic">No automated items saved.</li>`;
                } else {
                    dailyFoodEntries.forEach((item, index) => {
                        const li = document.createElement('li');
                        li.className = 'flex justify-between items-center group';
                        li.innerHTML = `
                            <span>${item}</span>
                            <button class="remove-daily-item-btn text-red-500 hover:text-red-700 transition-colors duration-200 opacity-0 group-hover:opacity-100" data-index="${index}">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4">
                                    <path d="M6.28 5.22a.75.75 0 0 0-1.06 1.06L8.94 10l-3.72 3.72a.75.75 0 1 0 1.06 1.06L10 11.06l3.72 3.72a.75.75 0 1 0 1.06-1.06L11.06 10l3.72-3.72a.75.75 0 0 0-1.06-1.06L10 8.94 6.28 5.22Z" />
                                </svg>
                            </button>
                        `;
                        dailyFoodList.appendChild(li);
                    });
                }
            };
            
            /** Shows the main application page and hides others. */
            const showMainApp = () => {
                mainAppContainer.classList.remove('hidden');
                settingsPage.classList.add('hidden');
                analysisPage.classList.add('hidden');
                foodInput.value = ''; // Clear input field
                updateNextDayButtonState();
            };
            
            /** Shows the settings page and hides others. */
            const showSettingsPage = () => {
                mainAppContainer.classList.add('hidden');
                settingsPage.classList.remove('hidden');
                analysisPage.classList.add('hidden');
                updateSettingsUI();
            };

            /** Shows the analysis page and hides others. */
            const showAnalysisPage = () => {
                mainAppContainer.classList.add('hidden');
                settingsPage.classList.add('hidden');
                analysisPage.classList.remove('hidden');
                analysisContentEl.innerHTML = `<p class="text-center text-gray-500">Analyzing your data...</p>`;
            };

            /** Updates the UI elements in the settings page. */
            const updateSettingsUI = () => {
                
                // Get today's date for API request count
                const today = formatDate(new Date());
                if (apiRequests.date !== today) {
                    apiRequests = { count: 0, date: today };
                }
                apiRequestCountEl.textContent = apiRequests.count;
                
                calorieTargetInput.value = dailyCalorieTarget;
                const targets = calculateTargets();
                macroTargetsEl.textContent = `P: ${Math.round(targets.protein)}g, F: ${Math.round(targets.fat)}g, C: ${Math.round(targets.carbs)}g`;
                
                // Update Goals input field
                goalsInput.value = userGoals;

                // Update API settings display
                console.log(API_URL);
                //apiUrlInput.placeholder = API_URL; //DEFAULT_API_URL;
                apiUrlInput.value = API_URL; 
                const apiKeyDisplay = API_KEY ? '********' : 'Not Set';
                currentApiKeyEl.textContent = apiKeyDisplay;

                // Update the checkbox state
                useCacheCheckbox.checked = useFoodCache;
                
                renderDailyFoodList();
            };
            
            /**
             * Handles exponential backoff for API calls.
             * @param {function} fn The function to execute.
             * @param {number} retries The number of retries remaining.
             * @param {number} delay The current delay in milliseconds.
             */
            const withBackoff = async (fn, retries = 5, delay = 1000) => {
                try {
                    return await fn();
                } catch (error) {
                    if (retries > 0 && (error.status === 429 || error.status === 500 || error.status === 503)) {
                        await new Promise(res => setTimeout(res, delay));
                        return withBackoff(fn, retries - 1, delay * 2);
                    }
                    throw error;
                }
            };


			/**
			 * Calls a text-based LLM API with the given prompt.
			 * It dynamically handles both traditional API formats and Pollinations.ai.
			 * @param {string} prompt The text prompt to send to the LLM.
			 * @param {string} [imageData=null] The image data URL to send for image analysis.
			 * @returns {Promise<string>} A promise that resolves to the LLM's raw text response.
			 */
			async function callLLM(prompt, imageData = null) {
				const settings = {
					API_URL: API_URL,
					API_KEY: API_KEY
				};
			
				if (imageData) {
					console.log("Image data found");
					if (settings.API_URL.includes("pollinations")) {
						const { base64, mimeType } = dataURLtoBase64AndMime(imageData);
						const imageFormat = mimeType.split('/')[1].toLowerCase();
			
						const payload = {
							model: "openai",
							messages: [{
								role: "user",
								content: [{
									type: "text",
									text: prompt
								}, {
									type: "image_url",
									image_url: {
										url: imageData // Use the full data URL string directly
									}
								}]
							}],
							max_tokens: 500
						}
			
						const url = `https://text.pollinations.ai/openai`;
						try {
							const response = await fetch(url, {
								method: 'POST',
								headers: { 'Content-Type': 'application/json' },
								body: JSON.stringify(payload)
							});
							console.log(response);
			
							if (!response.ok) {
								const errorText = await response.text();
								throw new Error(`API error: ${response.statusText} - ${errorText}`);
							}
			
							const result = await response.json();
							return result.choices[0].message.content;
						} catch (err) {
							console.error("Pollinations.ai image call failed:", err);
							throw err;
						}
					} else {
						// standard API call for image analysis
						if (!settings.API_KEY) throw new Error("API key is not set.");
						const { base64, mimeType } = dataURLtoBase64AndMime(imageData);
			
						const payload = {
							contents: [{
								parts: [
									{ text: prompt },
									{ inlineData: { mimeType, data: base64 } }
								]
							}]
						};
			
						const url = `${settings.API_URL}?key=${settings.API_KEY}`;
						try {
							const response = await fetch(url, {
								method: 'POST',
								headers: { 'Content-Type': 'application/json' },
								body: JSON.stringify(payload)
							});
							console.log(response);                
			
							if (!response.ok) {
								const errorData = await response.json();
								throw new Error(`API error: ${response.statusText} - ${JSON.stringify(errorData)}`);
							}
			
							const result = await response.json();
			
							if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
								return result.candidates[0].content.parts[0].text;
							} else {
								console.error("API Error:", result);
								throw new Error('Failed to get a valid response from the API.');
							}
						} catch (err) {
							console.error("API call with image failed:", err);
							throw err;
						}
					}
				} else { // No image data, proceed with the original text-only logic
					console.log("No image data found");
					if (settings.API_URL.includes("pollinations")) {
						const url = `${settings.API_URL}/${encodeURIComponent(prompt).replace(/%3F/g, '?').replace(/%3D/g, '=').replace(/%26/g, '&')}`;
						try {
							const response = await fetch(url, { method: 'GET' });
							if (!response.ok) throw new Error("Network error: " + response.status);
							const text = await response.text();
							console.log(text);
							return text;
						} catch (err) {
							console.error("Pollinations.ai call failed:", err);
							throw err;
						}
					} else {
						if (!settings.API_KEY) throw new Error("API key is not set.");
			
						const payload = {
							contents: [{
								parts: [{
									text: prompt
								}]
							}],
							generationConfig: {
								responseMimeType: "text/plain"
							}
						};
			
						const response = await fetch(`${settings.API_URL}?key=${settings.API_KEY}`, {
							method: 'POST',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify(payload)
						});
						console.log(response);
			
						if (!response.ok) {
							const errorData = await response.json();
							throw new Error(`API error: ${response.statusText} - ${JSON.stringify(errorData)}`);
						}
			
						const result = await response.json();
			
						if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
							return result.candidates[0].content.parts[0].text;
						} else {
							console.error("API Error:", result);
							throw new Error('Failed to get a valid response from the API.');
						}
					}
				}
			}
						
			
			
			/**
			 * Calls the LLM API to get nutritional information for a food query.
			 * @param {string} foodQuery The user's food entry string.
			 * @returns {Promise<object>} A promise that resolves to an object with nutritional data.
			 */
			const getNutritionData = async (foodQuery) => {
				const prompt = `Provide the nutritional information for "${foodQuery}". Respond only with a JSON object. The JSON should have the following structure: { "food_name": "...", "calories": 0, "protein": 0, "fat": 0, "carbs": 0 }. All values should be numerical (calories, protein, fat, carbs) and represent the total for the specified serving. Do not respond with anything other than a properly formed JSON object. If you do not know the values then provide your best guess. Any other response is unacceptable.?json=true`;
				
				const today = formatDate(new Date());
				if (apiRequests.date !== today) {
					apiRequests = { count: 0, date: today };
				}
				apiRequests.count++;
				localStorage.setItem('apiRequests', JSON.stringify(apiRequests));
				apiRequestCountEl.textContent = apiRequests.count;
			
				try {
					const llmResponse = await callLLM(prompt);
					
					let jsonText = llmResponse;
					
					// Remove Markdown code block if present
					if (jsonText.startsWith("```json")) {
						jsonText = jsonText.replace(/^```json\s*|\s*```$/g, '');
					}
			
					const nutritionData = JSON.parse(jsonText);
					
					if (nutritionData && nutritionData.food_name) {
						return nutritionData;
					} else {
						return null;
					}
				} catch (e) {
					console.error('API call failed:', e);
					showMessage('Failed to get nutrition data. Please check your API key and URL in settings.', 3000);
					return null;
				}
			};
			


			
			/**
			 * Calls the LLM API to get a compassionate, gentle analysis of historical data.
			 * @param {object} historicalData The user's saved nutrition data.
			 * @param {string} userGoals The user's goals.
			 * @returns {Promise<string>} A promise that resolves to the text analysis.
			 */
			const getAnalysisFromAPI = async (historicalData, userGoals) => {
				let prompt = `Please analyze the following nutrition data kindly and gently. The user may be struggling with disordered eating, so it is absolutely imperative that your analysis and suggestions are supportive, encouraging, and non-judgmental. Do not use words like 'good', 'bad', 'failed', or 'perfect'. Instead, focus on trends, consistency, and positive progress. Your goal is to provide a caring perspective on their nutrition journey. Explain the trends you see in their nutrition over time and offer a few simple, actionable, and gentle suggestions to help them on their journey. The suggestions should be about overall patterns, not specific days or foods. Return only plain text.`;
				
				if (userGoals) {
					prompt += `\n\nTake the user's personal goals into consideration for your analysis. Their goals are: "${userGoals}"`;
				}
				
				prompt += `\n\nHistorical Data:
				${JSON.stringify(historicalData, null, 2)}`;
				
				try {
					// Use the new, unified callLLM function
					//const analysisText = await callLLM(prompt, 'text/plain');
					const analysisText = await callLLM(prompt);
					return analysisText;
				} catch (e) {
					console.error('Analysis API call failed:', e);
					return "I'm sorry, I was unable to perform the analysis. Please check your API settings and try again later.";
				}
			};

            /**
             * Generates simple, simulated data for the chart on the first run.
             * @returns {object} An object with labels and data for a 7-day period.
             */
            const generateSimulatedChartData = () => {
                const today = new Date();
                const labels = [];
                const calories = [];
                const protein = [];
                const fat = [];
                const carbs = [];

                const baseCalories = 1800;
                const baseProtein = 90;
                const baseFat = 60;
                const baseCarbs = 200;

                for (let i = 6; i >= 0; i--) {
                    const d = new Date(today);
                    d.setDate(today.getDate() - i);
                    labels.push(formatDate(d));
                    
                    // Simple random variance for the chart data
                    const variance = Math.random() * 0.2 - 0.1; // -10% to +10%
                    calories.push(baseCalories * (1 + variance));
                    protein.push(baseProtein * (1 + variance));
                    fat.push(baseFat * (1 + variance));
                    carbs.push(baseCarbs * (1 + variance));
                }

                return { labels, calories, protein, fat, carbs };
            };
            
			/**
			 * Updates both the line chart and the pie chart with historical data.
			 * @param {object} historicalData The processed historical data.
			 * @param {object} targets The daily target values.
			 */
			const updateCharts = (historicalData, targets) => {
				// Logic for the line chart (your existing code)
				const labels = Object.keys(historicalData).sort();
				const data = {
					labels: labels,
					datasets: [
						{
							label: 'Calories (% of Target)',
							data: labels.map(date => (historicalData[date].calories / targets.calories) * 100),
							borderColor: 'rgb(25, 135, 84)',
							backgroundColor: 'rgba(25, 135, 84, 0.5)',
							tension: 0
						},
						{
							label: 'Protein (% of Target)',
							data: labels.map(date => (historicalData[date].protein / targets.protein) * 100),
							borderColor: 'rgb(54, 162, 235)',
							backgroundColor: 'rgba(54, 162, 235, 0.5)',
							tension: 0
						},
						{
							label: 'Fat (% of Target)',
							data: labels.map(date => (historicalData[date].fat / targets.fat) * 100),
							borderColor: 'rgb(255, 159, 64)',
							backgroundColor: 'rgba(255, 159, 64, 0.5)',
							tension: 0
						},
						{
							label: 'Carbs (% of Target)',
							data: labels.map(date => (historicalData[date].carbs / targets.carbs) * 100),
							borderColor: 'rgb(255, 99, 132)',
							backgroundColor: 'rgba(255, 99, 132, 0.5)',
							tension: 0
						}
					]
				};
			
				const config = {
					type: 'line',
					data: data,
					options: {
						responsive: true,
						maintainAspectRatio: false, // Ensures responsiveness works
						plugins: {
							legend: {
								position: 'top',
							},
							tooltip: {
								callbacks: {
									label: function(context) {
										let label = context.dataset.label || '';
										if (label) {
											label += ': ';
										}
										label += Math.round(context.raw) + '%';
										return label;
									}
								}
							}
						},
						scales: {
							y: {
								title: {
									display: true,
									text: 'Percentage of Daily Target (%)'
								},
								min: 0,
								ticks: {
									callback: function(value) {
										return value + '%';
									}
								}
							},
							x: {
								title: {
									display: true,
									text: 'Date'
								}
							}
						}
					},
				};
			
				if (myChart) {
					myChart.destroy();
				}
				const historicalChartCanvas = document.getElementById('historical-chart');
				myChart = new Chart(historicalChartCanvas, config);
				
				// Now, call the new function to update the macro pie chart
				updateMacroPieChart(historicalData);
			};
			
			/**
			 * Calculates and updates the macronutrient pie chart with historical data.
			 * @param {object} historicalData The processed historical data.
			 */
			const updateMacroPieChart = (historicalData) => {
				const dates = Object.keys(historicalData);
				if (dates.length === 0) return; // Exit if no data is available
			
				let totalProteinCalories = 0;
				let totalFatCalories = 0;
				let totalCarbsCalories = 0;
				let totalAllCalories = 0;
			
				// Calculate total calories from each macro based on common conversion factors
				// 1g Protein = 4 cal, 1g Fat = 9 cal, 1g Carbs = 4 cal
				dates.forEach(date => {
					const dayData = historicalData[date];
					totalProteinCalories += dayData.protein * 4;
					totalFatCalories += dayData.fat * 9;
					totalCarbsCalories += dayData.carbs * 4;
				});
			
				totalAllCalories = totalProteinCalories + totalFatCalories + totalCarbsCalories;
			
				// Calculate the percentage for each macronutrient
				const proteinPercentage = (totalProteinCalories / totalAllCalories) * 100;
				const fatPercentage = (totalFatCalories / totalAllCalories) * 100;
				const carbsPercentage = (totalCarbsCalories / totalAllCalories) * 100;
			
				const data = {
					labels: ['Protein', 'Fat', 'Carbs'],
					datasets: [{
						label: 'Calories from Macronutrients',
						data: [proteinPercentage, fatPercentage, carbsPercentage],
						backgroundColor: [
							'rgba(54, 162, 235, 0.8)', // Blue for Protein
							'rgba(255, 159, 64, 0.8)', // Orange for Fat
							'rgba(255, 99, 132, 0.8)', // Red for Carbs
						],
						hoverOffset: 4
					}]
				};
			
				const config = {
					type: 'pie',
					data: data,
					options: {
						responsive: true,
						maintainAspectRatio: false,
						plugins: {
							legend: {
								position: 'top',
							},
							title: {
								display: true,
								text: 'Average Macronutrient Ratio'
							}
						}
					}
				};
			
				// Destroy any existing chart instance to prevent duplicates
				if (macroPieChart) {
					macroPieChart.destroy();
				}
				const macroPieChartCanvas = document.getElementById('macro-pie-chart');
				macroPieChart = new Chart(macroPieChartCanvas, config);
			};


            
            /**
             * Converts a nested JavaScript object of food entries into a CSV string.
             * @param {object} data The allFoodEntries object.
             * @returns {string} The CSV formatted string.
             */
            const convertToCsv = (data) => {
                const headers = ["Date", "Food", "Calories", "Protein(g)", "Fat(g)", "Carbs(g)"];
                let csvContent = headers.join(",") + "\n"; // Add header row

                // Get sorted dates to ensure chronological order
                const dates = Object.keys(data).sort();

                dates.forEach(date => {
                    const dailyEntries = data[date];
                    if (dailyEntries && dailyEntries.length > 0) {
                        dailyEntries.forEach(item => {
                            // Escape quotes in the food name by replacing them with double quotes
                            const escapedFoodText = `"${item.text.replace(/"/g, '""')}"`;
                            const row = [
                                `"${date}"`,
                                escapedFoodText,
                                Math.round(item.calories || 0), // Handle pending items
                                Math.round(item.protein || 0),
                                Math.round(item.fat || 0),
                                Math.round(item.carbs || 0)
                            ].join(",");
                            csvContent += row + "\n";
                        });
                    }
                });
                return csvContent;
            };

            // --- Event Listeners and Initializers ---
            
            /**
             * Processes the pending items queue by attempting to fetch their data.
             */
            const processPendingItems = async () => {
                let processedCount = 0;
                
                // Get all pending items across all dates
                const allPendingItems = [];
                for (const date in allFoodEntries) {
                    allPendingItems.push(...allFoodEntries[date].filter(item => item.isPending));
                
                }
                
                
                if (allPendingItems.length === 0) {
                    // showMessage("No pending items to process.",2000);
                    return;
				} else {
					showMessage(`Processing ${allPendingItems.length} pending item(s)...`, 2000);                    
                }
                
                
                

                for (const item of allPendingItems) {
                    try {
                        const nutritionData = await getNutritionData(item.text);
                        if (nutritionData && 
                            typeof nutritionData.calories === 'number' && 
                            typeof nutritionData.protein === 'number' &&
                            typeof nutritionData.fat === 'number' &&
                            typeof nutritionData.carbs === 'number') {
                            
                            // Find the original item in the array and update its values
                            const dateKey = formatDate(new Date(item.timestamp));
                            const originalItem = allFoodEntries[dateKey].find(i => i.id === item.id);
                            
                            if (originalItem) {
                                originalItem.text = nutritionData.food_name || originalItem.text;
                                originalItem.calories = nutritionData.calories;
                                originalItem.protein = nutritionData.protein;
                                originalItem.fat = nutritionData.fat;
                                originalItem.carbs = nutritionData.carbs;
                                originalItem.isPending = false; // Mark as processed
                                processedCount++;
                            }
                            
                            // Save to cache
                            if (useFoodCache) {
                                foodCache[item.text.toLowerCase()] = {
                                    food_name: originalItem.text,
                                    calories: originalItem.calories,
                                    protein: originalItem.protein,
                                    fat: originalItem.fat,
                                    carbs: originalItem.carbs
                                };
                                saveFoodCache();
                            }
                        }
                    } catch (e) {
                        console.error('Failed to process pending item:', e);
                        // Item remains pending if it fails
                    }
                }

                if (processedCount > 0) {
                    renderFoodList();
                    updateTotals();
                    showMessage(`Processed ${processedCount} item(s) successfully!`, 3000);
                } else {
                    //showMessage('No pending items could be processed at this time.', 3000);
                }
            };

            // Load saved data and initialize the app
            const initializeApp = async () => {
                const savedEntries = localStorage.getItem('allFoodEntries');
                if (savedEntries) {
                    try {
                        allFoodEntries = JSON.parse(savedEntries);
                    } catch (e) {
                        console.error('Failed to parse saved data.', e);
                        allFoodEntries = {};
                    }
                }
                
                const savedFoodCache = localStorage.getItem('foodCache');
                if (savedFoodCache) {
                    try {
                        foodCache = JSON.parse(savedFoodCache);
                    } catch (e) {
                        console.error('Failed to parse saved food cache.', e);
                        foodCache = {};
                    }
                }
                
                const savedUseCache = localStorage.getItem('useFoodCache');
                if (savedUseCache !== null) {
                    useFoodCache = JSON.parse(savedUseCache);
                }
                
                // After loading the food entries, check each item for NaN values
                // and update its pending state accordingly.
                const dateKeys = Object.keys(allFoodEntries);
                dateKeys.forEach(dateKey => {
                    updatePendingState(dateKey);
                });                

                loadDailyEntries();
                loadCalorieTarget();
                loadGoals();
                
                // Add automated daily foods if the day is new
                const today = formatDate(new Date());
                const lastVisit = localStorage.getItem('lastVisitDate');
                if (lastVisit !== today) {
                    dailyFoodEntries.forEach(async (food) => {
                        await handleAddItem(food);
                    });
                    localStorage.setItem('lastVisitDate', today);
                }

                const savedApiRequests = localStorage.getItem('apiRequests');
                if (savedApiRequests) {
                    apiRequests = JSON.parse(savedApiRequests);
                }

                const savedApiKey = localStorage.getItem('apiKey');
                if (savedApiKey) {
                    API_KEY = savedApiKey;
                }
                
                const savedApiUrl = localStorage.getItem('apiUrl');
                if (savedApiUrl) {
                    API_URL = savedApiUrl;
                }
                
                currentDateEl.textContent = formatDisplayDate(currentDate);
                renderFoodList();
                updateTotals();
                showMainApp();
                
                // Finally, process all pending items after the app has been initialized
                processPendingItems();                
            };
            
			const updateNextDayButtonState = () => {
							const today = new Date();
							const isToday = formatDate(currentDate) === formatDate(today);
							
							currentDateEl.textContent = formatDisplayDate(currentDate);
							
							if (isToday) {
								nextDayBtn.disabled = true;
								nextDayBtn.classList.add('opacity-0', 'cursor-not-allowed');
							} else {
								nextDayBtn.disabled = false;
								nextDayBtn.classList.remove('opacity-0', 'cursor-not-allowed');
							}
						};            
            
			/** Handles adding a new food item, including API call. */
			const handleAddItem = async (foodText) => {
				const foodQuery = foodText
					// trim pre- and post- whitespace
					.trim()
					// replace & ? = with words to not confuse a url based LLM API
					.replace(/\?/g, '')
					.replace(/&/g, ' and ')
					.replace(/=/g, ' equals ');
			
				if (!foodQuery) {
					processPendingItems(); // Process pending items if the input is empty
					return;
				}
			
				showMessage('Adding item...');
				addItemBtn.disabled = true;
			
				let nutritionData = null;
				let fromCache = false;
			
				// Create a new entry, pending or not
				const newEntry = {
					id: Date.now(),
					text: foodText,
					timestamp: new Date().toISOString(),
					calories: 0,
					protein: 0,
					fat: 0,
					carbs: 0,
					isPending: true // Assume pending until API response is processed
				};
			
				const dateKey = formatDate(currentDate);
				if (!allFoodEntries[dateKey]) {
					allFoodEntries[dateKey] = [];
				}
				// push new item to top of list
				allFoodEntries[dateKey].unshift(newEntry);
				foodInput.value = ''; // Clear input field
				renderFoodList();
			
				// Check if caching is enabled AND if the food is already in the cache
				if (useFoodCache && foodCache[foodQuery.toLowerCase()]) {
					nutritionData = foodCache[foodQuery.toLowerCase()];
					showMessage('Item found in cache!');
					fromCache = true;
				} else {
					try {
						nutritionData = await getNutritionData(foodQuery);
					} catch (error) {
						console.error('Error fetching data from API:', error);
						nutritionData = null; // Ensure nutritionData is null on API failure
					}
				}
				// clear "adding item" message
				clearMessage();
			
				// Process the data based on API response
				if (nutritionData &&
					typeof nutritionData.calories === 'number' &&
					typeof nutritionData.protein === 'number' &&
					typeof nutritionData.fat === 'number' &&
					typeof nutritionData.carbs === 'number') {
			
					// Update the newly created entry with real data
					newEntry.text = nutritionData.food_name || foodText;
					newEntry.calories = nutritionData.calories;
					newEntry.protein = nutritionData.protein;
					newEntry.fat = nutritionData.fat;
					newEntry.carbs = nutritionData.carbs;
					newEntry.isPending = false;
			
					// Save the new data to the cache if caching is enabled and it came from the API (not cache)
					if (useFoodCache && !fromCache) {
						foodCache[foodQuery.toLowerCase()] = nutritionData;
						saveFoodCache();
					}
			
					showMessage(`${newEntry.text} added!`,2000);
					// Now, process all other pending items
					await processPendingItems();
				} else {
					// This happens if the API call failed or returned bad data
					showMessage(`Item "${foodText}" saved as pending.`, 5000);
					// The item remains in the list as "pending"
				}
			
				renderFoodList();
				updateTotals();
				addItemBtn.disabled = false;			
			};
						
			

            // --- New functions for saving and loading settings ---
            
            /** Saves current settings to a local JSON file. */
            const saveSettingsToFile = () => {
                const settings = {
                    dailyCalorieTarget: dailyCalorieTarget,
                    dailyFoodEntries: dailyFoodEntries,
                    userGoals: userGoals,
                    API_URL: API_URL,
                    API_KEY: API_KEY,
                    useFoodCache: useFoodCache
                };
                const jsonContent = JSON.stringify(settings, null, 2);
                const blob = new Blob([jsonContent], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'nutrition_settings.json';
                a.click();
                URL.revokeObjectURL(url);
                showMessage('Settings saved to file!',3000);
            };

            /** Loads settings from a local JSON file. */
            const loadSettingsFromFile = () => {
                loadSettingsInput.click();
            };

            // Event listener for the hidden settings file input
            loadSettingsInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) {
                    return;
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const loadedSettings = JSON.parse(event.target.result);
                        
                        // Use a consistent object-based approach to load settings
                        if (loadedSettings.dailyCalorieTarget !== undefined) {
                            dailyCalorieTarget = loadedSettings.dailyCalorieTarget;
                            saveCalorieTarget();
                        }
                        if (loadedSettings.dailyFoodEntries !== undefined) {
                            dailyFoodEntries = loadedSettings.dailyFoodEntries;
                            saveDailyEntries();
                        }
                        if (loadedSettings.userGoals !== undefined) {
                            userGoals = loadedSettings.userGoals;
                            saveGoals();
                        }
                        if (loadedSettings.API_URL !== undefined) {
                            API_URL = loadedSettings.API_URL;
                            localStorage.setItem('apiUrl', API_URL);
                        }
                        if (loadedSettings.API_KEY !== undefined) {
                            API_KEY = loadedSettings.API_KEY;
                            localStorage.setItem('apiKey', API_KEY);
                        }
                        if (loadedSettings.useFoodCache !== undefined) {
                            useFoodCache = loadedSettings.useFoodCache;
                            localStorage.setItem('useFoodCache', useFoodCache);
                        }
                        
                        // Re-render the UI with the new settings
                        updateSettingsUI();
                        updateTotals();
                        showMessage('Settings loaded successfully!',2000);

                    } catch (error) {
                        console.error('Error loading settings file:', error);
                        showMessage('Failed to load settings. Please ensure it is a valid JSON file.', 5000);
                    }
                };
                reader.readAsText(file);
            });
            
            /** Loads historical data from a local CSV file. */
            const loadDataFromFile = () => {
                loadDataInput.click();
            };

            // Event listener for the hidden data file input
            loadDataInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) {
                    return;
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const csvContent = event.target.result;
                        const lines = csvContent.split('\n').filter(line => line.trim() !== '');
                        if (lines.length < 2) {
                            showMessage('Invalid CSV format. Please include headers and data.', 3000);
                            return;
                        }

                        const headers = lines[0].split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/).map(h => h.trim().replace(/"/g, ''));
                        const newEntries = {};

                        lines.slice(1).forEach(line => {
                            const values = line.split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/).map(v => v.trim().replace(/"/g, ''));
                            if (values.length !== headers.length) return; // Skip malformed lines

                            const entry = {};
                            headers.forEach((header, i) => {
                                let value = values[i];
                                if (['Calories', 'Protein(g)', 'Fat(g)', 'Carbs(g)'].includes(header)) {
                                    entry[header.split('(')[0].toLowerCase()] = parseFloat(value);
                                } else if (header === 'Date') {
                                    entry.date = value;
                                } else if (header === 'Food') {
                                    entry.text = value;
                                }
                            });

                            if (entry.date) {
                                if (!newEntries[entry.date]) {
                                    newEntries[entry.date] = [];
                                }
                                // Add a unique ID and timestamp for consistency
                                newEntries[entry.date].push({
                                    id: Date.now() + newEntries[entry.date].length,
                                    text: entry.text,
                                    calories: entry.calories || 0,
                                    protein: entry.protein || 0,
                                    fat: entry.fat || 0,
                                    carbs: entry.carbs || 0,
                                    timestamp: new Date(entry.date).toISOString()
                                });
                            }
                        });

                        // Append the new entries to the existing data
                        Object.keys(newEntries).forEach(date => {
                            if (allFoodEntries[date]) {
                                allFoodEntries[date] = allFoodEntries[date].concat(newEntries[date]);
                            } else {
                                allFoodEntries[date] = newEntries[date];
                            }
                        });

                        renderFoodList();
                        updateTotals();
                        showMessage('CSV data loaded successfully!',2000);

                    } catch (error) {
                        console.error('Error loading CSV file:', error);
                        showMessage('Failed to load CSV. Please check the file format.', 5000);
                    }
                };
                reader.readAsText(file);
            });

			// Main "Add Item" button listener
			addItemBtn.addEventListener('click', async () => {
				// handle the primary task of adding the food item.
				await handleAddItem(foodInput.value);
				// clear the text box
				foodInput.value = '';
			
				// Once the item is processed and the total is updated, get the final value.
				const finalTotalCalories = document.getElementById('total-calories').innerText;
			});
			
			clearBtn.addEventListener('click', () => {
				foodInput.value = '';
				foodInput.focus();
				document.getElementById('autocomplete-suggestions').classList.add('hidden');
			});		

			// Event delegation for delete and edit buttons
			foodListContainer.addEventListener('click', async (e) => {
				const deleteBtn = e.target.closest('.delete-item-btn');
				const editBtn = e.target.closest('.edit-item-btn');
			
				if (deleteBtn) {
					const index = parseInt(deleteBtn.dataset.index, 10);
					const dateKey = formatDate(currentDate);
					const item = allFoodEntries[dateKey][index];
					
					const modalHtml = `
						<h3 class="font-bold text-lg mb-2">Delete Item</h3>
						<p class="text-sm text-gray-600 mb-4">Are you sure you want to delete "${item.text}"?</p>
						<div class="flex justify-end gap-2">
							<button id="modal-cancel-btn" class="px-4 py-2 text-gray-600 rounded-lg hover:bg-gray-200 transition-colors duration-200">Cancel</button>
							<button id="modal-confirm-btn" class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors duration-200">Delete</button>
						</div>
					`;
					
					showModal(modalHtml, (e) => { // Now the callback receives the event 'e'
						allFoodEntries[dateKey].splice(index, 1);
						renderFoodList();
						updateTotals();
						showMessage('Item deleted.',2000);
					});
				}
								
				if (editBtn) {
					const index = parseInt(editBtn.dataset.index, 10);
					const dateKey = formatDate(currentDate);
					const item = allFoodEntries[dateKey][index];
				
					const modalHtml = `
						<h3 class="font-bold text-lg mb-2">Edit Item</h3>
						<p class="text-sm text-gray-600 mb-2">Enter new nutritional values for "${item.text}".</p>
						<div class="space-y-2 mb-4">
							<label for="modal-food-name" class="text-sm font-medium text-gray-700">Food Name</label>
							<input type="text" id="modal-food-name" class="w-full p-2 border rounded-lg" placeholder="Food Name" value="${item.text}">
							<label for="modal-calories" class="text-sm font-medium text-gray-700">Calories</label>
							<input type="number" id="modal-calories" class="w-full p-2 border rounded-lg" placeholder="Calories" value="${Math.round(item.calories)}">
							<label for="modal-protein" class="text-sm font-medium text-gray-700">Protein (g)</label>
							<input type="number" id="modal-protein" class="w-full p-2 border rounded-lg" placeholder="Protein (g)" value="${Math.round(item.protein)}">
							<label for="modal-fat" class="text-sm font-medium text-gray-700">Fat (g)</label>
							<input type="number" id="modal-fat" class="w-full p-2 border rounded-lg" placeholder="Fat (g)" value="${Math.round(item.fat)}">
							<label for="modal-carbs" class="text-sm font-medium text-gray-700">Carbs (g)</label>
							<input type="number" id="modal-carbs" class="w-full p-2 border rounded-lg" placeholder="Carbs (g)" value="${Math.round(item.carbs)}">
						</div>
						<div class="flex justify-end gap-2">
							<button id="modal-add-to-today-btn" class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors duration-200">Add to Today</button>
							<button id="modal-cancel-btn" class="px-4 py-2 text-gray-600 rounded-lg hover:bg-gray-200 transition-colors duration-200">Cancel</button>
							<button id="modal-confirm-btn" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors duration-200">Save</button>
						</div>
					`;
				
					showModal(modalHtml, async (e, modalContentEl) => {
						const clickedBtnId = e.target.id;
				
						if (clickedBtnId === 'modal-add-to-today-btn') {
							// Use the new helper function
							addFoodItemToToday(item, dateKey);
						} else if (clickedBtnId === 'modal-confirm-btn') {
							// ... (existing "Save" logic remains here) ...
				
							const newText = modalContentEl.querySelector('#modal-food-name').value.trim();
							const oldText = item.text.trim();
							const newCalories = parseFloat(modalContentEl.querySelector('#modal-calories').value);
							const newProtein = parseFloat(modalContentEl.querySelector('#modal-protein').value);
							const newFat = parseFloat(modalContentEl.querySelector('#modal-fat').value);
							const newCarbs = parseFloat(modalContentEl.querySelector('#modal-carbs').value);
				
							// Check if the food text has changed
							if (newText.toLowerCase() !== oldText.toLowerCase()) {
								showMessage('Re-calculating nutrition data...', 5000);
				
								let nutritionData;
								if (useFoodCache && foodCache[newText.toLowerCase()]) {
									nutritionData = foodCache[newText.toLowerCase()];
									showMessage('Item found in cache!',2000);
								} else {
									nutritionData = await getNutritionData(newText);
								}
				
								if (nutritionData) {
									allFoodEntries[dateKey][index].text = nutritionData.food_name || newText;
									allFoodEntries[dateKey][index].calories = nutritionData.calories;
									allFoodEntries[dateKey][index].protein = nutritionData.protein;
									allFoodEntries[dateKey][index].fat = nutritionData.fat;
									allFoodEntries[dateKey][index].carbs = nutritionData.carbs;
									allFoodEntries[dateKey][index].isPending = false;
									showMessage('Item and nutrition data updated.',2000);
								} else {
									showMessage('Could not find nutrition data for the new item. Keeping previous values.', 5000);
									allFoodEntries[dateKey][index].text = newText;
									allFoodEntries[dateKey][index].isPending = true;
								}
							} else {
								// If only the numbers were changed, update them directly
								allFoodEntries[dateKey][index].text = newText;
								allFoodEntries[dateKey][index].calories = newCalories;
								allFoodEntries[dateKey][index].protein = newProtein;
								allFoodEntries[dateKey][index].fat = newFat;
								allFoodEntries[dateKey][index].carbs = newCarbs;
								allFoodEntries[dateKey][index].isPending = false;
								showMessage('Item updated successfully.',2000);
							}
							renderFoodList();
							updateTotals();
						}
					});
				}
			});

            // Date navigation button listeners
            prevDayBtn.addEventListener('click', () => {
                currentDate.setDate(currentDate.getDate() - 1);
                currentDateEl.textContent = formatDisplayDate(currentDate);
                renderFoodList();
                updateTotals();
                updateNextDayButtonState();
            });

            nextDayBtn.addEventListener('click', () => {
                currentDate.setDate(currentDate.getDate() + 1);
                currentDateEl.textContent = formatDisplayDate(currentDate);
                renderFoodList();
                updateTotals();
                updateNextDayButtonState();
            });

            // Goals input listener to save changes instantly
            goalsInput.addEventListener('input', (e) => {
                userGoals = e.target.value;
                saveGoals();
            });

            // Open settings button listener
            openSettingsBtn.addEventListener('click', showSettingsPage);

            // Close settings button listener
            closeSettingsBtn.addEventListener('click', showMainApp);

            // Close analysis page button listener
            closeAnalysisBtn.addEventListener('click', showMainApp);
            
            // Save daily calorie target button listener
            saveTargetBtn.addEventListener('click', () => {
                const newTarget = parseInt(calorieTargetInput.value, 10);
                if (newTarget > 0) {
                    dailyCalorieTarget = newTarget;
                    saveCalorieTarget();
                    updateTotals();
                    updateSettingsUI();
                    showMessage('Daily target saved!',2000);
                } else {
                    showMessage('Please enter a valid calorie target.', 3000);
                }
            });
            
            // Save daily food item button listener
            saveDailyFoodBtn.addEventListener('click', () => {
                const foodText = dailyFoodInput.value.trim();
                if (foodText) {
                    dailyFoodEntries.push(foodText);
                    dailyFoodInput.value = '';
                    saveDailyEntries();
                    showMessage('Daily food item added.',2000);
                }
            });

            // Event delegation for removing daily food items
            dailyFoodList.addEventListener('click', (e) => {
                const removeBtn = e.target.closest('.remove-daily-item-btn');
                if (removeBtn) {
                    const index = parseInt(removeBtn.dataset.index, 10);
                    dailyFoodEntries.splice(index, 1);
                    saveDailyEntries();
                    showMessage('Daily food item removed.',2000);
                }
            });
            
            // Save API settings button listener
            saveApiSettingsBtn.addEventListener('click', () => {
                console.log('Save button clicked!'); // Add this line
                const newApiUrl = apiUrlInput.value.trim();
                const newApiKey = apiKeyInput.value.trim();
                const newUseCache = useCacheCheckbox.checked;
                console.log(newApiUrl);
                
                if (newApiUrl) {
                    API_URL = newApiUrl;
                    localStorage.setItem('apiUrl', API_URL);
                    console.log(API_URL);
                }
                
                if (newApiKey) {
                    API_KEY = newApiKey;
                    localStorage.setItem('apiKey', API_KEY);
                }
                
                // Update and save the cache setting
                useFoodCache = newUseCache;
                localStorage.setItem('useFoodCache', useFoodCache);

                updateSettingsUI();
                showMessage('API settings saved!',2000);
                console.log(`Saved API settings`,2000);
            });

            // "Default URL" button listener
            defaultApiUrlBtn.addEventListener('click', () => {
                apiUrlInput.value = DEFAULT_API_URL;
                showMessage('API URL set to default.',2000);
            });

            // Export data button listener
            exportBtn.addEventListener('click', () => {
                // Convert all food data into a CSV string
                const csvContent = convertToCsv(allFoodEntries);
                
                // Create a Blob with the CSV data and set the MIME type to 'text/csv'
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'nutrition_data.csv'; // Set the file name
                a.click();
                URL.revokeObjectURL(url);
                showMessage('Data exported!',2000);
            });
            
            // Save settings button listener
            saveSettingsBtn.addEventListener('click', saveSettingsToFile);
            
            // Load settings button listener
            loadSettingsBtn.addEventListener('click', loadSettingsFromFile);

            // Load data button listener
            loadDataBtn.addEventListener('click', loadDataFromFile);

            // Clear data button listener
            clearDataBtn.addEventListener('click', () => {
                const modalHtml = `
                    <h3 class="font-bold text-lg mb-2 text-red-600">Clear All Data</h3>
                    <p class="text-sm text-gray-600 mb-4">This will permanently delete all your saved nutrition entries. This action cannot be undone.</p>
                    <div class="flex justify-end gap-2">
                        <button id="modal-cancel-btn" class="px-4 py-2 text-gray-600 rounded-lg hover:bg-gray-200 transition-colors duration-200">Cancel</button>
                        <button id="modal-confirm-btn" class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors duration-200">Clear All Data</button>
                    </div>
                `;
                showModal(modalHtml, () => {
                    localStorage.clear();
                    allFoodEntries = {};
                    apiRequests = { count: 0, date: '' };
                    dailyFoodEntries = [];
                    currentDate = new Date();
                    dailyCalorieTarget = 2000;
                    foodCache = {}; // New: Clear food cache
                    useFoodCache = true; // New: Reset to default value
                    userGoals = ""; // New: Clear user goals
                    
                    initializeApp(); // Re-initialize to reset the app state
                    showMessage('All data cleared!',2000);
                });
            });
            
            // Analyze Data button listener
            analyzeDataBtn.addEventListener('click', async () => {
                showAnalysisPage();
                
                // Exclude pending items from the analysis
                const nonPendingEntries = {};
                for (const date in allFoodEntries) {
                    nonPendingEntries[date] = allFoodEntries[date].filter(item => !item.isPending);
                }

                if (Object.keys(nonPendingEntries).length === 0) {
                    // First run with no data, use static text and simulated chart data
                    analysisContentEl.innerHTML = `<p class="text-gray-700">This is where the LLM will provide a textual historical analysis of your saved data.</p>`;
                    
                    const simulatedData = generateSimulatedChartData();
                    const targets = calculateTargets();
                    const chartData = {};
                    simulatedData.labels.forEach((label, index) => {
                        chartData[label] = {
                            calories: simulatedData.calories[index],
                            protein: simulatedData.protein[index],
                            fat: simulatedData.fat[index],
                            carbs: simulatedData.carbs[index]
                        };
                    });
                    
                    updateCharts(chartData, targets);
                    
                } else {
                    // Normal run with user data
                    try {
                        const analysisText = await getAnalysisFromAPI(nonPendingEntries, userGoals);
                        const analysisHtml = convertMarkdownToHtml(analysisText);
                        analysisContentEl.innerHTML = analysisHtml;
                        
                        // Process historical data for the chart
                        const targets = calculateTargets();
                        const historicalData = {};
                        const dates = Object.keys(nonPendingEntries);
                        dates.sort((a, b) => new Date(a) - new Date(b));

                        dates.forEach(date => {
                            const dailyTotals = nonPendingEntries[date].reduce((acc, curr) => {
                                acc.calories += curr.calories;
                                acc.protein += curr.protein;
                                acc.fat += curr.fat;
                                acc.carbs += curr.carbs;
                                return acc;
                            }, { calories: 0, protein: 0, fat: 0, carbs: 0 });
                            historicalData[date] = dailyTotals;
                        });
                        
                        updateCharts(historicalData, targets);
                        
                    } catch (e) {
                        console.error('Error during analysis:', e);
                        analysisContentEl.innerHTML = `<p class="text-red-500">Sorry, there was an error processing your request. Please try again later.</p>`;
                    }
                }
            });

            // Initial call to set up the app on page load
            initializeApp();
        });
    </script>
</body>
</html>